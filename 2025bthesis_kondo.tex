%
% 特別研究II 研究報告書（近藤惇斗）
%
\documentclass[jlreq,twoside]{jsreport}
\usepackage{csg-thesis} % 論文テンプレートパッケージ
\usepackage{url} % URL表示用
\usepackage[dvipdfmx]{graphicx}
\usepackage{hyperref}
\usepackage{listings,jvlisting} % 日本語のコメントアウトをする場合
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes,arrows,positioning}

% ここからソースコードの表示に関する設定
\lstset{
  basicstyle={\ttfamily},
  identifierstyle={\small},
  commentstyle={\small\itshape},
  keywordstyle={\small\bfseries},
  ndkeywordstyle={\small},
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},
  numbers=left,
  xrightmargin=0zw,
  xleftmargin=3zw,
  numberstyle={\scriptsize},
  stepnumber=1,
  numbersep=1zw,
  lineskip=-0.5ex
}

% 題目 T5
\title{ChatGPT を用いた\\
Python コード難読化と構造的類似度分析ツールの評価} %T5

% 特別研究II研究報告書
\degree{特別研究II研究報告書}

% 名前
\author{近藤  惇斗}

% 提出日
\date{2025年2月10日}

% 卒業年度
\schoolyear{2025年}

% 所属
\department{京都産業大学 情報理工学部 情報理工学科}

% 学籍番号
\stnumber{253550}

% 指導教員
\supervisor{玉田 壮一郎 教授}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 概要
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
近年、ソースコードの難読化は、ソフトウェアのリバースエンジニアリング対策や不正利用防止の観点から重要性が増している。
しかし、一般的な難読化ツールはブラックボックスであり、具体的にどのような難読化手法が適用され、その結果コード構造がどの程度変化したのかを利用者が把握しづらいという問題がある。

本研究では、Python ソースコードを対象とした難読化と、難読化前後のコード構造の変化を可視化・定量化するツール「T5」の実装と評価を行った。
提案ツールは、抽象構文木（AST）ノード頻度の分布に基づくコサイン類似度、木編集距離に基づく AST 構造類似度、制御フローグラフ（CFG）に由来する特徴量の類似度、およびサイクロマチック複雑度など複数の指標を算出し、難読化前後の差異をレポートとして出力する。
さらに、難読化前後のコード断片を生成 AI（ChatGPT、Gemini）に入力し、用いられている難読化手法を自然言語で説明させ、その結果を Markdown 形式でレポートに埋め込む仕組みを実装した。

実験として、100~200 行程度の Python コードを中心に複数のサンプルプログラムを収集し、自作の難読化スクリプトや既存難読化手法を適用した上で、本ツールにより類似度や複雑度の変化を測定した。
その結果、多くの難読化パターンにおいて AST ノード頻度の類似度は 0.9 以上と高い一方で、木編集距離や CFG 類似度、サイクロマチック複雑度には顕著な差が現れることが確認された。
また、生成 AI による難読化手法の説明は、人手による分析と概ね整合する内容であり、レポートの読みやすさ向上に有用であることが分かった。

本研究により、コード難読化を単に適用するだけでなく、「何が」「どの程度」変化したかを定量的かつ説明的に理解できる一助となることが期待される。
\end{abstract}

% 謝辞
\begin{acknowledgments}

\end{acknowledgments}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\listoffigures
\listoftables

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 本文
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{はじめに}
\section{研究背景}
ソースコードの難読化は、ソフトウェアの保護やセキュリティ強化を目的として広く利用されている。
特に Python のようなスクリプト言語はソースコードの配布・解析が容易であるため、アルゴリズムやビジネスロジックの秘匿、ライセンス違反の抑止などの観点から難読化の重要性が高い。

一方で、既存の難読化ツールは「難読化後のコードを出力する」ことを主目的としており、
\begin{itemize}
  \item どのような難読化手法（識別子の難読化、制御フローの分岐増殖、デッドコード挿入など）が使われているのか
  \item 難読化前後でコード構造がどの程度変化しているのか
\end{itemize}
をユーザが把握することは容易ではない。
結果として、難読化の「強度」や「可読性への影響」を研究レベルで評価したい場合に、定量的な比較が行いにくいという課題がある。

\section{研究目的}
本研究の目的は、Python コードを対象とした難読化前後の構造的な変化を多面的な指標で捉え、その結果を可視化・レポート化するツールを実装・評価することである。
具体的には、以下を実現する。
\begin{enumerate}
  \item 抽象構文木（AST）、制御構造、サイクロマチック複雑度など複数の観点から難読化前後のコードを比較する仕組みの設計
  \item Python AST に基づくノード頻度、木編集距離、CFG 由来の特徴量、Cyclomatic Complexity などの指標を算出する Python ツールの実装
  \item 生成 AI（ChatGPT、Gemini）を用いて、難読化前後コードの差分から「使用されている難読化手法」を自然言語で説明させ、HTML レポートに埋め込むフローの構築
  \item 複数のサンプルプログラムを用いた実験により、提案ツールの有用性と限界を分析すること
\end{enumerate}

\section{本稿の構成}
本稿の構成は以下の通りである。
第\ref{chap:related}章では、プログラム難読化およびコード解析に関する関連研究について述べる。
第\ref{chap:method}章では、本研究で提案する難読化比較ツール T5 の設計と実装について説明する。
第\ref{chap:evaluation}章では、サンプルコードを用いた評価実験の方法と結果を示す。
第\ref{chap:discussion}章では、得られた結果の考察と本ツールの有用性・課題について議論する。
第\ref{chap:conclusion}章では、本研究の結論と今後の展望について述べる。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{関連研究}
\label{chap:related}

\section{プログラム難読化手法}
プログラム難読化手法は、大きく以下のように分類されることが多い。
\begin{itemize}
  \item \textbf{レイアウト・識別子難読化}\\
  コメントやインデントの削除、無意味な空白の挿入、変数名・関数名を意味のない識別子に変更する手法である。
  構文木レベルでは大きな変化が生じない場合も多いが、可読性を大きく低下させる。
  \item \textbf{制御フロー難読化}\\
  条件分岐やループ構造を再構成したり、不透明述語（常に真または偽であるが静的には判定しにくい条件）を利用することで、実行経路を追いにくくする手法である。
  CFG レベルの構造に大きな影響を与える。
  \item \textbf{データ難読化}\\
  定数の分割・再構成や暗号化、配列インデックスの変形など、データ表現を変化させる手法である。
  実行時には元の値が復元されるが、静的解析を困難にする。
\end{itemize}

本研究が対象とする Python コードはインタプリタ言語であり、Java バイトコードや C のバイナリを対象とした従来研究と比べて、ソースコード情報が豊富に利用できる点が特徴である。
そのため、本研究では AST や CFG などソースコードレベルの構造情報を活用する。

\section{コード構造の解析と類似度指標}
ソースコードの構造比較には、AST や CFG に基づく手法が多数提案されている。
AST ノード頻度のベクトル化とコサイン類似度は実装が容易で、大まかな構造の近さを測ることができるが、ノードの並びや入れ子構造までは捉えにくい。
これに対し、木編集距離はノードの挿入・削除・置換の最小コストとして木構造間の差分を定義し、より厳密な比較が可能であるが、計算コストが高いという課題がある。

また、制御フローに着目した指標として、基本ブロック数、分岐数、ループ数、最大ネスト深さなどの CFG 由来の特徴量や、McCabe のサイクロマチック複雑度が広く利用されている。
これらは、難読化による制御構造の複雑化の程度を定量的に把握するのに有用である。

\section{生成 AI を利用したコード解析}
近年、大規模言語モデル（LLM）を用いたコード解析・説明生成の研究が活発である。
LLM にコード断片や差分を入力し、リファクタリング案やバグの可能性、設計意図などを自然言語で説明させる試みが行われている。
本研究では、難読化前後のコードペアを LLM に与え、そこから推測される難読化手法を箇条書きで説明させることで、「定量指標」と「自然言語による解説」を組み合わせたレポート生成を行う点に特徴がある。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{提案手法}
\label{chap:method}

\section{難読化ツール の概要}
本研究で実装したツールは、図\ref{fig:system}に示すように、以下の三つのモジュールから構成される。
\begin{enumerate}
  \item \textbf{特徴量抽出モジュール}\\
  Python の AST や CFG、サイクロマチック複雑度などを計算し、難読化前後のコードから各種指標を抽出する。
  \item \textbf{類似度計算モジュール}\\
  抽出した特徴量に対してコサイン類似度や木編集距離に基づく正規化類似度を計算し、表・グラフとしてまとめる。
  \item \textbf{レポート生成モジュール}\\
  計算結果と、生成 AI （Gemini）による難読化手法の説明文を HTML レポートとして出力する。
\end{enumerate}

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance=2.0cm, >=stealth, font=\small]

    % 入力コード
    \node[draw, rounded corners, align=center] (readable)
      {難読化前コード\\readable.py};
    \node[draw, rounded corners, align=center, below=of readable] (obfus)
      {難読化後コード\\obfuscated.py};

    % T5 解析ツール（中身はざっくり2行だけ）
    \node[draw, thick, rounded corners, align=center,
          minimum width=6cm, minimum height=3cm,
          right=3cm of readable.south east, anchor=north west] (core)
      {T5 解析ツール\\[0.4em]
       コード解析・特徴量抽出\\
       類似度計算・レポート生成};

    % 入力 → T5
    \draw[->] (readable.east) -- (core.west |- readable.east);
    \draw[->] (obfus.east)    -- (core.west |- obfus.east);

    % 出力レポート
    \node[draw, rounded corners, align=center,
          right=3cm of core] (html)
      {HTMLレポート\\diff\_report.html};

    \draw[->] (core.east) -- (html.west);

    % Gemini API
    \node[draw, rounded corners, align=center,
          above=1.5cm of core] (gemini)
      {生成AI（Gemini API）\\難読化手法の説明};

    \draw[<->] (core.north) -- node[right]{コード断片／説明文} (gemini.south);

  \end{tikzpicture}
  \caption{提案ツール T5 の簡略システム構成図}
  \label{fig:system-t5-simple}
\end{figure}



\section{特徴量抽出}
\subsection{AST ノード頻度}
Python の \texttt{ast} モジュールを用いてソースコードを構文解析し、\texttt{ast.walk} により全ノードを走査することでノード種別の頻度分布を得る。
得られた分布をベクトル化し、難読化前後のベクトル間でコサイン類似度を算出する。
類似度が 1 に近いほど構文レベルの構成は似ており、0 に近いほど異なると解釈できる。

\subsection{AST 構造類似度（木編集距離）}
AST の形状そのものを比較するために、簡略化した木構造クラス \texttt{SimpleNode} を定義し、再帰的に子ノードをたどる木編集距離アルゴリズムを実装した。
木編集距離を $d$、それぞれの木のサイズを $|T_1|, |T_2|$ としたとき、正規化類似度 $s$ を
\[
s = 1 - \frac{d}{\max(|T_1|, |T_2|)}
\]
と定義し、0～1 の範囲で解釈可能とした。

\subsection{CFG 特徴量}
制御構造に関する特徴量として、関数定義数、if 文数、for 文数、while 文数、try 文数、return 文数、break 文数、continue 文数、および最大ネスト深さをカウントするクラス \texttt{CFGFeatureExtractor} を実装した。
これらを 1 本の特徴ベクトルとし、難読化前後のベクトル間でコサイン類似度を算出する。

\subsection{サイクロマチック複雑度}
ライブラリ \texttt{radon} を用いて各関数・メソッドのサイクロマチック複雑度を計算し、平均値および合計値を指標として用いた。
難読化により分岐が増えたり、条件がネストされた場合、この指標が上昇することが期待される。

\section{レポート生成}
\subsection{数値レポートとグラフ}
上記の特徴量と類似度を \texttt{pandas.DataFrame} で整形し、表形式で HTML に埋め込むとともに、
\texttt{matplotlib} を用いて行数・識別子数・平均識別子長・サイクロマチック複雑度の比較グラフを描画し、Base64 形式で HTML に埋め込んだ。

\subsection{生成 AI による難読化手法の説明}
難読化前後のコードを 120 行までに切り出し、その 2 つをプロンプトとして Gemini API に送信し、
\begin{itemize}
  \item 用いられている難読化手法の名称
  \item その手法がコード内のどのような変換に対応しているか
\end{itemize}
を Markdown 形式の箇条書きで説明させるプロンプトを設計した。
得られた Markdown 文字列は Python の \texttt{markdown} ライブラリで HTML に変換し、レポート末尾に「Gemini による難読化手法の説明」として埋め込む実装とした。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{評価}
\label{chap:evaluation}

\section{評価環境}
評価は Mac 環境（macOS、Python 3.11）上で実施し、依存ライブラリとして \texttt{radon}、\texttt{pandas}、\texttt{scikit-learn}、\texttt{markdown} などを使用した。
Gemini API については Google Cloud Console 上でプロジェクトを作成し、Generative Language API を有効化した上で API キーを発行し、環境変数 \texttt{GEMINI\_API\_KEY} から参照するよう設定した。

\section{評価用データセット}
評価には、自作およびインターネット上のサンプルコードから収集した 50～100 行程度の Python プログラムを中心に、複数のプログラムを用いた。
各プログラムに対して、以下の難読化パターンを用意した。
\begin{itemize}
  \item 識別子の一括リネーム（短い無意味な名前への変更）
  \item GUI コードにおけるラベル文字列の \texttt{chr()} 分割による構築
  \item 無意味な if 文やループを挿入する制御フロー難読化
  \item デッドコード（実行されない関数・条件分岐）の挿入
\end{itemize}

\section{指標ごとの結果概要}

\subsection{AST ノード頻度の類似度}
識別子リネームや文字列の構築方法のみを変更した難読化では、AST ノード頻度のコサイン類似度は 0.9 以上と高い値を保つことが多かった。
これは、構文構造そのものはほぼ同一であり、表層的な識別子やリテラルの違いに留まっていることを示している。

一方、制御フローを大きく書き換える難読化や、多数のデッドコードを挿入した場合には、類似度が 0.7～0.8 程度まで低下するケースも確認された。

\subsection{AST 構造類似度（木編集距離）}
木編集距離に基づく正規化類似度は、単純なリネームでは高い値を示しつつ、制御構造の入れ替えやネストの変更には敏感に反応した。
特に GUI コードに対して、イベントハンドラの分割やラッパ関数の追加といった難読化を施した場合、AST ノード頻度の類似度よりも大きく低下することが確認できた。

\subsection{CFG 類似度とサイクロマチック複雑度}
CFG 由来の特徴ベクトルの類似度は、分岐やループの数を増加させる難読化で顕著に低下した。
同時に、サイクロマチック複雑度の平均値・合計値も上昇する傾向が見られ、制御フローの複雑化が定量的に捉えられていることが分かった。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{考察}
\label{chap:discussion}

%\section{指標の補完関係}

%\begin{itemize}
  %\item 表層的な変更（識別子や定数の変更）
  %\item 構造的な変更（制御フローの変形、関数分割）
%\end{itemize}
%をバランスよく把握できることが示唆される。

\section{生成 AI による説明の有用性と限界}
生成 AI による難読化手法の説明は、人間が見ても納得できるレベルの分類・命名（「制御フローの難読化」「デッドコードの挿入」など）を行えており、
数値指標だけでは直感的に理解しづらい点を補う役割を果たした。

一方で、
\begin{itemize}
  \item 入力として与えるコード断片が長くなると、API 制限や応答時間の増加が問題になる
  \item 部分的なコードしか見ていないため、実際には行っていない難読化手法を誤って推測する可能性がある
\end{itemize}
といった限界も存在する。
本研究では先頭 120 行に切り詰めるなどの対策を行ったが、今後はプロンプト設計や要約の工夫により、より安定した説明生成を目指す必要がある。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{結果と今後の展望}
\label{chap:conclusion}

\if0 
\section{本研究のまとめ}
本研究では、Python コードの難読化前後を対象として、AST、CFG、サイクロマチック複雑度など複数の指標により構造的な変化を定量化し、
さらに生成 AI による難読化手法の自然言語説明を統合したレポート生成ツール  を実装した。

実験を通じて、
\begin{itemize}
  \item 識別子リネームなどの表層的な難読化では AST ノード頻度の類似度は高いままであること
  \item 制御フローを大きく書き換える難読化では、木編集距離や CFG 類似度、サイクロマチック複雑度が大きく変化すること
  \item 生成 AI による難読化手法の説明が、人手による分析と概ね整合し、レポートの理解を補助すること
\end{itemize}
を示した。
\fi

\if0
\section{今後の課題と展望}
今後の課題として、以下が挙げられる。
\begin{itemize}
  \item 評価対象とするコードの種類・規模を増やし、より大規模な実験を行うこと
  \item 構造類似度の計算アルゴリズムを高速化し、長大なコードやプロジェクト全体への適用を可能にすること
  \item 生成 AI による説明の精度を系統的に評価し、誤った説明が生成された場合の検知・補正方法を検討すること
  \item 難読化の「強度」を総合指標として数値化し、ツール間の比較やパラメータ調整に応用すること
\end{itemize}

本研究で構築した T5 は、プログラム難読化の教育・研究・実務において、「難読化の効果を見える化するツール」として活用可能であると考えられる。
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 参考文献
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nocite{*}
\bibliographystyle{csg-thesis}
\bibliography{2025bthesis_kondo}

\end{document}
