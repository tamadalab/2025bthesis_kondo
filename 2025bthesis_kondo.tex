%
% 特別研究II 研究報告書（近藤惇斗）
%
\documentclass[jlreq,twoside]{jsreport}
\usepackage{csg-thesis} % 論文テンプレートパッケージ
\usepackage{url} % URL表示用
\usepackage[dvipdfmx]{graphicx}
\usepackage{hyperref}
\usepackage{listings,jvlisting} % 日本語のコメントアウトをする場合
\usepackage{tikz}
\usepackage{chngcntr}
\counterwithout{figure}{chapter}
\counterwithout{table}{chapter}
\usepackage{amsmath}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes,arrows,positioning}

% ここからソースコードの表示に関する設定
\lstset{
  basicstyle={\ttfamily},
  identifierstyle={\small},
  commentstyle={\small\itshape},
  keywordstyle={\small\bfseries},
  ndkeywordstyle={\small},
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},
  numbers=left,
  xrightmargin=0zw,
  xleftmargin=3zw,
  numberstyle={\scriptsize},
  stepnumber=1,
  numbersep=1zw,
  lineskip=-0.5ex
}

% 題目 T5
\title{ChatGPT を用いた\\
Python コード難読化と構造的類似度分析ツールの評価}

% 特別研究II研究報告書
\degree{特別研究II研究報告書}

% 名前
\author{近藤  惇斗}

% 提出日
\date{2025年2月10日}

% 卒業年度
\schoolyear{2025年}

% 所属
\department{京都産業大学 情報理工学部 情報理工学科}

% 学籍番号
\stnumber{253550}

% 指導教員
\supervisor{玉田 壮一郎 教授}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 概要
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
近年、ソースコードの難読化は、ソフトウェアのリバースエンジニアリング対策や不正利用防止の観点から重要性が増している。
しかし、一般的な難読化ツールはブラックボックスであり、具体的にどのような難読化手法が適用され、その結果コード構造がどの程度変化したのかを利用者が把握しづらいという問題がある。

本研究では、Python のソースコードを対象とした難読化と、難読化前後のコード構造の変化を可視化・定量化するツールの実装と評価を行った。
本ツールは、抽象構文木（AST）ノード頻度の分布に基づくコサイン類似度、木編集距離に基づく AST 構造類似度、制御フローグラフ（CFG）に由来する特徴量の類似度、およびサイクロマチック複雑度（Cyclomatic Complexity, McCabe）など複数の指標を算出し、難読化前後の違いをレポートとして出力する。
さらに、難読化前後のコード断片を生成 AI（ChatGPT、Gemini）に入力し、用いられている難読化手法を自然言語で説明させ、その結果を Markdown 形式でレポートに埋め込む仕組みを実装した。

実験として、100〜200 行程度の Python コードを中心に複数のサンプルプログラムを収集し、自作の難読化スクリプトや既存難読化手法を適用した上で、難読化ツールにより類似度や複雑度の変化を測定した。
その結果、多くの難読化パターンにおいて AST ノード頻度の類似度は 0.9 以上と高い一方で、木編集距離や CFG 類似度、サイクロマチック複雑度には差が現れることが確認された。

本研究により、コード難読化を単に適用するだけでなく、「何が」「どの程度」変化したかを定量的かつ説明的に理解できる一助となることが期待される。
\end{abstract}

% 謝辞
\begin{acknowledgments}
本研究を進めるにあたり、終始懇切丁寧なご指導ならびに多くのご助言を賜りました、
京都産業大学情報理工学部情報理工学科 玉田 壮一郎 教授に、心より感謝申し上げます。
研究の進め方から論文のまとめ方に至るまで、多大なるご指導をいただきましたこと、
深く御礼申し上げます。

また、日頃より貴重なご意見やご助言をいただきました研究室の皆様に、
厚く御礼申し上げます。
さらに、本研究を進めるにあたり支えてくれた友人や家族に対しても、
この場を借りて感謝の意を表します。
\end{acknowledgments}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\listoffigures
\listoftables

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 本文
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{はじめに}
\section{研究背景}
ソースコードの難読化は、ソフトウェアの保護やセキュリティ強化を目的として広く利用されている。
特に Python のようなスクリプト言語はソースコードの配布・解析が容易であるため、アルゴリズムやビジネスロジックの秘匿、ライセンス違反の抑止などの観点から難読化の重要性が高い。

一方で、既存の難読化ツールは「難読化後のコードを出力する」ことを主目的としており、
\begin{itemize}
  \item どのような難読化手法（識別子の難読化、制御フローの分岐増殖、デッドコード挿入など）が使われているのか
  \item 難読化前後でコード構造がどの程度変化しているのか
\end{itemize}
をユーザが把握することは容易ではない。
結果として、難読化の「強度」や「可読性への影響」を研究レベルで評価したい場合に、定量的な比較が行いにくいという課題がある。

\section{研究目的}
本研究の目的は、Python コードを対象とした難読化前後の構造的な変化を複数の指標で捉え、その結果を可視化・レポート化するツールを実装・評価することである。
具体的には、以下を実現する。
\begin{enumerate}
  \item 抽象構文木（AST）、制御構造、サイクロマチック複雑度など複数の観点から難読化前後のコードを比較する仕組みの設計
  \item Python AST に基づくノード頻度、木編集距離、CFG 由来の特徴量、サイクロマチック複雑度などの指標を算出するツールの実装
  \item 生成 AI（ChatGPT、Gemini）を用いて、難読化前後コードの差分から「使用されている難読化手法」を自然言語で説明させ、HTML レポートに埋め込むフローの構築
  \item 複数のサンプルプログラムを用いた実験により、提案ツールの有用性と限界を分析すること
\end{enumerate}

\section{本稿の構成}
本稿の構成は以下の通りである。
第\ref{chap:related}章では、プログラム難読化およびコード解析に関する関連研究について述べる。
第\ref{chap:method}章では、本研究で提案する難読化比較ツールの設計と実装について説明する。
第\ref{chap:evaluation}章では、サンプルコードを用いた評価実験の方法と結果を示す。
第\ref{chap:result}章では、結果を総括し、本研究の結論につなげる要点を整理する。
第\ref{chap:discussion}章では、得られた結果の考察と本ツールの有用性・課題について議論する。
第\ref{chap:conclusion}章では、本研究のまとめと今後の課題・展望について述べる。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{関連研究}
\label{chap:related}

本章では本研究に関連する既存研究について述べる。
まずプログラム難読化に関する研究を概観し、
次にコード類似度解析や制御フロー解析に関する研究、
最後に生成AIを用いたコード理解および可視化に関する研究について述べる。

% ==================================================
\section{プログラム難読化に関する研究}
プログラム難読化はソフトウェアの解析や不正利用を防止する目的で
コードの可読性や解析容易性を意図的に低下させる技術である。
Collberg らは識別子難読化、制御フロー難読化、
データ難読化などの代表的な難読化手法を体系的に整理し、
難読化の強度やコストの評価指標について議論している。
これらの研究は難読化手法そのものの設計に重点を置いており、
難読化の影響を定量的に比較・評価する枠組みは十分に確立されていない。

% ==================================================
\section{Pythonコードに対する難読化手法}
近年 Python を対象とした難読化手法も提案されている。
動的型付け言語である Python では
変数名の変更や制御構造の変形に加え、
実行時評価や動的生成コードを用いた難読化が可能である。
一方でこれらの手法は可読性を著しく低下させるものの、
どの程度コード構造が変化したかを客観的に評価することは難しい。
本研究では Python コードを対象として、
構文構造および制御構造の変化を定量的に評価する点に特徴がある。

% ==================================================
\section{コードクローン検出と類似度解析}
コードクローン検出の分野では
ソースコード間の類似度を測定するための多様な手法が提案されている。
トークン列や文字列に基づく手法は実装が容易である一方、
識別子名変更などの影響を受けやすい。
これに対し抽象構文木（AST）を用いた手法は
コードの構文構造を直接比較できるため、
表層的な変更に対して頑健であるとされている。
本研究では AST ノード頻度に基づくコサイン類似度を用い、
難読化前後の構文構造の変化を評価する。

% ==================================================
\section{ASTに基づくコード類似度解析}
抽象構文木（AST）を用いたコード解析は
ソースコードの構文構造を木構造として表現できる点に特徴がある。
Roy らは AST を用いたコードクローン検出手法を提案し、
構文的な類似性の検出に有効であることを示した。
本研究では AST ノードの出現頻度を特徴量として抽出し、
コサイン類似度により難読化前後のコードを比較する。
これにより難読化によってどの程度構文構造が変化したかを
定量的に把握することが可能となる。

% ==================================================
\section{制御フローグラフとサイクロマチック複雑度}
制御フローグラフ（CFG）は
プログラム中の分岐やループ構造を表現するための代表的なモデルである。
McCabe によって提案されたサイクロマチック複雑度（Cyclomatic Complexity）は
CFGに基づいて算出される指標であり、
プログラムの複雑さやテスト容易性の評価に用いられてきた。
難読化では制御構造を意図的に複雑化する手法が多く、
CFGや複雑度指標は難読化評価において重要である。
本研究ではCFG全体を厳密に比較するのではなく、
分岐数や最大ネスト深さなどの特徴量を用いた
簡易的なCFG類似度評価を行っている。

% ==================================================
\section{生成AIによるコード理解と説明生成}
近年大規模言語モデル（LLM）を用いたコード理解に関する研究が進展している。
CodeBERT や GPT 系モデルは
ソースコードと自然言語を同時に学習することで
コード要約や自動説明生成を可能としている。
これらの研究は主に可読性向上や開発支援を目的としているが、
本研究では生成AIを難読化評価に応用する点が異なる。
具体的には Gemini API を用いて、
難読化前後のコードから使用された難読化手法を
自然言語で自動説明する。

% ==================================================
\section{難読化評価の可視化とツール化}
従来の難読化研究では
評価結果を数値や表として示すことが多く、
難読化の影響を直感的に把握しにくいという課題があった。
近年ではソフトウェア品質指標をグラフやHTMLレポートとして
可視化する研究やツールが提案されている。
本研究では AST 類似度、CFG 類似度、サイクロマチック複雑度などの指標を
HTML レポートとして自動生成し、
さらに生成AIによる説明文を統合することで
難読化の影響を多角的に評価できる点に特徴がある。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{提案手法}
\label{chap:method}

\section{難読化ツールの概要}
\label{sec:tool-overview}

今回の研究で使用した難読化ツールは図\ref{fig:system-t5-simple}に示すように、次の3つのモジュールから構成される。
\begin{enumerate}
  \item\textbf{特徴量抽出モジュール}\\
  Python の AST や CFG、サイクロマチック複雑度などを計算し、難読化前後のコードからそれぞれの指標を抽出する。
  \item \textbf{類似度計算モジュール}\\
  抽出した特徴量に対してコサイン類似度や木編集距離に基づく正規化類似度を計算し、表・グラフとしてまとめる。
  \item \textbf{レポート生成モジュール}\\
  計算結果と、生成 AI による難読化手法の説明文を HTML レポートとして出力する。
\end{enumerate}

なお、本稿では用語の表記ゆれを避けるため、以降「サイクロマチック複雑度（Cyclomatic Complexity, McCabe）」を「サイクロマチック複雑度」と表記する。

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance=2.0cm, >=stealth, font=\small]

    % 入力コード
    \node[draw, rounded corners, align=center] (readable)
      {難読化前コード\\readable.py};
    \node[draw, rounded corners, align=center, below=of readable] (obfus)
      {難読化後コード\\obfuscated.py};

    % 解析ツール
    \node[draw, thick, rounded corners, align=center,
          minimum width=6cm, minimum height=3cm,
          right=3cm of readable.south east, anchor=north west] (core)
      {解析ツール\\[0.4em]
       コード解析・特徴量抽出\\
       類似度計算・レポート生成};

    % 入力 → 解析ツール
    \draw[->] (readable.east) -- (core.west |- readable.east);
    \draw[->] (obfus.east)    -- (core.west |- obfus.east);

    % 出力レポート
    \node[draw, rounded corners, align=center,
          right=3cm of core] (html)
      {HTMLレポート\\diff\_report.html};

    \draw[->] (core.east) -- (html.west);

    % Gemini API
    \node[draw, rounded corners, align=center,
          above=1.5cm of core] (gemini)
      {生成AI（Gemini API）\\難読化手法の説明};

    \draw[<->] (core.north) -- node[right]{コード断片／説明文} (gemini.south);

  \end{tikzpicture}
  \caption{難読化ツールの簡略システム構成図}
  \label{fig:system-t5-simple}
\end{figure}

\section{特徴量抽出}
\subsection{AST ノード頻度}
Python の \texttt{ast} モジュールを用いてソースコードを構文解析し、\texttt{ast.walk} により全ノードを走査することでノード種別の頻度分布を得る。
得られた分布をベクトル化し、難読化前後のベクトル間でコサイン類似度を算出する。
類似度が 1 に近いほど構文レベルの構成は似ており、0 に近いほど異なると解釈できる。

\subsection{AST 構造類似度（木編集距離）}
AST の形状そのものを比較するために、簡略化した木構造クラス \texttt{SimpleNode} を定義し、再帰的に子ノードをたどる木編集距離アルゴリズムを実装した。
木編集距離を $d$、それぞれの木のサイズを $|T_1|, |T_2|$ としたとき、正規化類似度 $s$ を
\[
s = 1 - \frac{d}{\max(|T_1|, |T_2|)}
\]
と定義し、0～1 の範囲で解釈可能とした。

\subsection{CFG 特徴量}
制御構造に関する特徴量として、関数定義数、if 文数、for 文数、while 文数、try 文数、return 文数、break 文数、continue 文数、および最大ネスト深さをカウントするクラス \texttt{CFGFeatureExtractor} を実装した。
これらを 1 本の特徴ベクトルとし、難読化前後のベクトル間でコサイン類似度を算出する。

\subsection{サイクロマチック複雑度}
ライブラリ \texttt{radon} を用いて各関数・メソッドのサイクロマチック複雑度を計算し、平均値および合計値を指標として用いた。
難読化により分岐が増えたり、条件がネストされた場合、この指標が上昇することが期待される。

\section{レポート生成}
\subsection{数値レポートとグラフ}
上記の特徴量と類似度を \texttt{pandas.DataFrame} で整形し、表形式で HTML に埋め込むとともに、
\texttt{matplotlib} を用いて行数・識別子数・平均識別子長・サイクロマチック複雑度の比較グラフを描画し、Base64 形式で HTML に埋め込んだ。

\subsection{生成 AI による難読化手法の説明}
難読化前後のコードを 120 行までに切り出し、その 2 つをプロンプトとして Gemini API に送信し、
\begin{itemize}
  \item 用いられている難読化手法の名称
  \item その手法がコード内のどのような変換に対応しているか
\end{itemize}
を Markdown 形式の箇条書きで説明させるプロンプトを設計した。
得られた Markdown 文字列は Python の \texttt{markdown} ライブラリで HTML に変換し、レポート末尾に「Gemini による難読化手法の説明」として埋め込む実装とした。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{評価}
\label{chap:evaluation}

本章では、提案手法を用いて生成した難読化コードについて、
複数の指標を用いて難読化前後の差異を定量的に評価する。
評価には、AST 構造類似度、CFG 類似度、
およびサイクロマチック複雑度を用いた。

\section{AST構造に基づく評価}
AST 構造類似度および AST ノード頻度に基づくコサイン類似度の結果から、
難読化後のコードは難読化前と比較して、
構文構造が大きく変化していることが確認された。
特に、AST ノード数の増加や、
差異が大きいノード（If、Call、Name 等）の増加が見られ、
コードの表層的な構造が複雑化していることが分かる。

これらの結果は、ChatGPT による難読化が、
識別子名の変更、処理の分割、
冗長な関数呼び出しの追加などを通じて、
構文木レベルでの構造を大きく変化させていることを示している。
そのため、AST に基づく類似度指標では、
難読化の効果が強く表れる結果となった。

\section{CFG類似度による評価}
CFG 特徴量に基づく類似度評価では、
難読化前後で分岐数やループ構造の数が増加する例は見られたものの、
類似度が完全に低下するケースは少なかった。
また、難読化を強く行った場合でも、
CFG 類似度が一定以上の値を保つ例が確認された。

この結果は、難読化後のコードにおいても、
プログラムの本質的な制御フロー、
すなわち処理の流れや条件分岐の意味的構造が、
大きくは変化していないことを示唆している。
ChatGPT は制御構造を冗長に書き換えることはできるものの、
制御フローそのものを根本的に変換することは難しいと考えられる。

\section{サイクロマチック複雑度による評価}
サイクロマチック複雑度の評価結果から、
難読化後のコードではブロック数が増加する一方で、
平均複雑度が必ずしも大きく増加しない場合が多く確認された。
これは、処理が細分化され、
関数単位の複雑度が分散されたことによる影響であると考えられる。

一方で、複雑度の合計値は増加する傾向があり、
コード全体としては冗長で複雑に見える構造となっている。
しかし、制御構造そのものの分岐数や条件の本質的な数は
大きく変化していないため、
制御フローの本質的な複雑さは保たれていることが分かる。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{結果}
\label{chap:result}

本章では、第\ref{chap:evaluation}章の評価結果を要約し、本研究の主張につながるポイントを整理する。

評価結果から、ChatGPT による難読化は、
識別子名の変更や処理の分割、冗長な関数呼び出しの挿入などにより、
構文構造（AST）を大きく変化させることが可能であることが確認された。
一方で、CFG 類似度やサイクロマチック複雑度の傾向から、
制御構造の本質的な部分（分岐やループの意味的な骨格）は、
難読化前後で大きく変化していないことが示唆された。

すなわち、「見た目（構文構造）は大きく変えられるが、中身（制御構造）は根本的に変えにくい」という傾向が得られた。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{考察}
\label{chap:discussion}

本研究の評価結果を総合すると、ChatGPT によるプログラム難読化には、
明確な特徴と限界が存在することが明らかとなった。

まず、AST 構造類似度や AST ノード頻度に基づく評価では、
難読化後のコードが難読化前と大きく異なる構文構造を持つことが確認された。
これは、ChatGPT が識別子の変更や処理の分割、
冗長な関数呼び出しの挿入などを通じて、
コードの表層的な構造を大きく変形できることを示している。
そのため、人間がソースコードを読んだ際の可読性は大きく低下し、
静的解析ツールによる単純な比較も困難になる。

一方で、CFG 類似度やサイクロマチック複雑度の結果から、
制御構造の本質的な部分は、難読化前後で大きく変化していないことが示唆された。
ChatGPT による難読化では、条件分岐やループが冗長に記述される場合はあるものの、
プログラムの意味を保持したまま、制御フローそのものを大きく組み替えることは難しいと考えられる。
これは、生成 AI が与えられた仕様や機能を維持することを強く優先するためである。

以上の結果から、「ChatGPT によるプログラム難読化は、構文構造を複雑にすることには有効であるが、
中身（制御構造）の本質的な変化を伴う難読化には限界がある」という結論が導かれる。
すなわち、見た目上は非常に複雑なコードを生成できる一方で、
制御フロー解析や CFG に基づく解析を行うことで、プログラムの本質的な挙動を把握できる可能性が残されている。

この考察は、AST 系指標と CFG 系指標を組み合わせて評価することの重要性を示しており、
単一の類似度指標のみでは、難読化の実態を正確に評価できないことを示唆している。
本研究で提案した多面的な評価手法は、生成 AI による難読化の特性を理解する上で有効な枠組みであると考えられる。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{結論}
\label{chap:conclusion}

\section{本研究のまとめ}
本研究では、ChatGPT を用いたプログラム難読化に着目し、
難読化前後のコードを比較・分析するための評価システムを構築した。
本システムでは、AST 構造類似度、CFG 類似度、サイクロマチック複雑度など、
複数の観点から難読化の影響を定量的に評価できる点を特徴とする。

評価実験の結果、ChatGPT による難読化は、
構文構造を大きく変化させることでコードの見た目を複雑にすることが可能である一方、
制御フローの本質的な構造を変えることは難しいという特徴を持つことが明らかとなった。
以上より、ChatGPT によるプログラム難読化は
「構造的には難しくできるが、中身（制御構造）は変えることが難しい」
という性質を持つことが示された。

\section{今後の課題と展望}
本研究には、いくつかの課題が残されている。
まず、本研究で扱ったプログラムの規模や種類は限定的であり、
より大規模なプログラムや異なる用途のプログラムに対しても
同様の傾向が成り立つかを検証する必要がある。

また、評価指標についても改良の余地がある。
本研究では CFG 特徴量を簡易的な形で抽出したが、
より詳細な制御フロー解析やパス単位での類似度評価を導入することで、
難読化の影響をより精緻に捉えることが可能になると考えられる。

さらに、ChatGPT 単体による難読化だけでなく、
既存の難読化ツールと組み合わせた場合の効果や、
複数回の難読化を適用した際の影響についても今後検討する価値がある。
将来的には、生成AIによる難読化を検出・解析する技術の確立や、
安全性評価への応用も視野に入れ、プログラム解析分野における生成AI活用の指針を示すことが目標である。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 参考文献
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\nocite{*}
\bibliographystyle{csg-thesis}
\bibliography{2025bthesis_kondo}

\end{document}
